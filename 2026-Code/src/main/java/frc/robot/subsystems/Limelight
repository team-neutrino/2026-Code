// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems;

import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.LimelightHelpers;
import frc.robot.util.Subsystem;
import static frc.robot.Constants.LimelightConstants.*;

public class Limelight extends SubsystemBase {
  LimelightHelpers m_limelightHelpers;
  double m_robotYaw;
  Swerve m_swerve;
  Rotation2d m_targetYaw;
  private double m_lastFrameFr = -2;
  private double m_lastFrameFl = -2;
  private double m_lastFrameBr = -2;
  private double m_lastFrameBl = -2;
  private double m_lastFrameShooter = -2;
  private boolean m_has_shooter_tag;
  private boolean m_has_fr_tag;
  private boolean m_has_fl_tag;
  private boolean m_has_br_tag;
  private boolean m_has_bl_tag;
  private boolean m_enabled = false;
  private long m_slow_count = 0;

  public Limelight() {
    m_swerve = Subsystem.swerve;
    m_limelightHelpers = new LimelightHelpers();
    // fake pipeline number
    // LimelightHelpers.setPipelineIndex(LIMELIGHT_1, 1);
    LimelightHelpers.setLEDMode_ForceOff(LL_BL);
    LimelightHelpers.setCameraPose_RobotSpace(LL_BL,
        BL_FORWARD_OFFSET, // Forward offset (meters)
        BL_SIDE_OFFSET, // Side offset (meters) left is positive
        BL_HEIGHT_OFFSET, // Height offset (meters)
        BL_ROLL_OFFSET, // Roll (degrfees)
        BL_PITCH_OFFSET, // Pitch (degrees)
        BL_YAW_OFFSET // Yaw (degrees)
    );
    LimelightHelpers.SetFiducialDownscalingOverride(LL_BL, 3);

    LimelightHelpers.setLEDMode_ForceOff(LL_BR);
    LimelightHelpers.setCameraPose_RobotSpace(LL_BR,
        BR_FORWARD_OFFSET, // Forward offset (meters)
        BR_SIDE_OFFSET, // Side offset (meters) left is positive
        BR_HEIGHT_OFFSET, // Height offset (meters)
        BR_ROLL_OFFSET, // Roll (degrees)
        BR_PITCH_OFFSET, // Pitch (degrees)
        BR_YAW_OFFSET // Yaw (degrees)
    );
    LimelightHelpers.SetFiducialDownscalingOverride(LL_BR, 3);

    LimelightHelpers.setLEDMode_ForceOff(LL_FL);
    LimelightHelpers.setCameraPose_RobotSpace(LL_FL,
        FL_FORWARD_OFFSET, // Forward offset (meters)
        FL_SIDE_OFFSET, // Side offset (meters) left is positive
        FL_HEIGHT_OFFSET, // Height offset (meters)
        FL_ROLL_OFFSET, // Roll (degrees)
        FL_PITCH_OFFSET, // Pitch (degrees)
        FL_YAW_OFFSET // Yaw (degrees)
    );

    LimelightHelpers.SetFiducialDownscalingOverride(FL, 3);

    LimelightHelpers.setLEDMode_ForceOff(LL_FR);
    LimelightHelpers.setCameraPose_RobotSpace(LL_FR,
        FR_FORWARD_OFFSET, // Forward offset (meters)
        FR_SIDE_OFFSET, // Side offset (meters) left is positive
        FR_HEIGHT_OFFSET, // Height offset (meters)
        FR_ROLL_OFFSET, // Roll (degrees)
        FR_PITCH_OFFSET, // Pitch (degrees)
        FR_YAW_OFFSET // Yaw (degrees)
    );

    LimelightHelpers.SetFiducialDownscalingOverride(FR, 3);

    LimelightHelpers.setLEDMode_ForceOff(LL_SHOOTER);
    LimelightHelpers.setCameraPose_RobotSpace(LL_SHOOTER,
        SHOOTER_FORWARD_OFFSET, // Forward offset (meters)
        SHOOTER_SIDE_OFFSET, // Side offset (meters) left is positive
        SHOOTER_HEIGHT_OFFSET, // Height offset (meters)
        SHOOTER_ROLL_OFFSET, // Roll (degrees)
        SHOOTER_PITCH_OFFSET, // Pitch (degrees)
        SHOOTER_YAW_OFFSET // Yaw (degrees)
    );

    LimelightHelpers.SetFiducialDownscalingOverride(LL_SHOOTER, 3);

    LimelightHelpers.SetIMUMode(LL_SHOOTER, 1);
    LimelightHelpers.SetIMUMode(LL_FR, 1);
    // use external IMU yaw submitted via setRobotOrientation() and configure the
    // LL4 internal IMU's fused yaw to match the submitted yaw value
  }

  /** True when the shooter camera currently sees a fiducial. */
  public boolean hasShooterTag() {
    return m_has_shooter_tag;
  }

  /** True when the front-right camera currently sees a fiducial. */
  public boolean hasFrontRightTag() {
    return m_has_fr_tag;
  }

  /** True when the front-left camera currently sees a fiducial. */
  public boolean hasFrontLeftTag() {
    return m_has_fl_tag;
  }

  /** True when the back-right camera currently sees a fiducial. */
  public boolean hasBackRightTag() {
    return m_has_br_tag;
  }

  /** True when the back-left camera currently sees a fiducial. */
  public boolean hasBackLeftTag() {
    return m_has_bl_tag;
  }

  // Backwards-compatible helpers used by existing odometry logic.
  // Map the old reef/station checks onto the new camera booleans so
  // existing updateOdometry() behavior continues to work.
  public boolean getTvFr() {
    return m_has_fr_tag;
  }

  public boolean getTvFl() {
    return m_has_fl_tag;
  }

  public boolean getTvShooter() {
    return m_has_shooter_tag;
  }

  public boolean getTvLr() {
    return m_has_fr_tag;
  }

  public boolean getTvLl() {
    return m_has_fl_tag;
  }


  private void updateOdometryFr() {
    LimelightHelpers.PoseEstimate limePoseEstReef = LimelightHelpers
        .getBotPoseEstimate_wpiBlue_MegaTag2(LL_FR);
    double frame = getFrame(LL_FR);
    if (limePoseEstReef != null && limePoseEstReef.tagCount != 0
        && m_swerve.getState().Speeds.omegaRadiansPerSecond < 4 * Math.PI
        && frame > m_lastFrameFr) {
      m_swerve.addVisionMeasurement(limePoseEstReef.pose, limePoseEstReef.timestampSeconds);
    }
    m_lastFrameFr = frame;
  }

  private void updateOdometryFl() {
    LimelightHelpers.PoseEstimate limePoseEstReef = LimelightHelpers
        .getBotPoseEstimate_wpiBlue_MegaTag2(LL_FL);
    double frame = getFrame(LL_FL);
    if (limePoseEstReef != null && limePoseEstReef.tagCount != 0
        && m_swerve.getState().Speeds.omegaRadiansPerSecond < 4 * Math.PI
        && frame > m_lastFrameFl) {
      m_swerve.addVisionMeasurement(limePoseEstReef.pose, limePoseEstReef.timestampSeconds);
    }
    m_lastFrameFl = frame;
  }

  private void updateOdometryBr() {
    LimelightHelpers.PoseEstimate limePoseEstReef = LimelightHelpers
        .getBotPoseEstimate_wpiBlue_MegaTag2(LL_BR);
    double frame = getFrame(LL_BR);
    if (limePoseEstReef != null && limePoseEstReef.tagCount != 0
        && m_swerve.getState().Speeds.omegaRadiansPerSecond < 4 * Math.PI
        && frame > m_lastFrameBr) {
      m_swerve.addVisionMeasurement(limePoseEstReef.pose, limePoseEstReef.timestampSeconds);
    }
    m_lastFrameBr = frame;
  }

  private void updateOdometryBl() {
    LimelightHelpers.PoseEstimate limePoseEstReef = LimelightHelpers
        .getBotPoseEstimate_wpiBlue_MegaTag2(LL_BL);
    double frame = getFrame(LL_BL);
    if (limePoseEstReef != null && limePoseEstReef.tagCount != 0
        && m_swerve.getState().Speeds.omegaRadiansPerSecond < 4 * Math.PI
        && frame > m_lastFrameBl) {
      m_swerve.addVisionMeasurement(limePoseEstReef.pose, limePoseEstReef.timestampSeconds);
    }
    m_lastFrameBl = frame;
  }

  private void updateOdometryShooter() {
    LimelightHelpers.PoseEstimate limePoseEstReef = LimelightHelpers
        .getBotPoseEstimate_wpiBlue_MegaTag2(LL_SHOOTER);
    double frame = getFrame(LL_SHOOTER);
    if (limePoseEstReef != null && limePoseEstReef.tagCount != 0
        && m_swerve.getState().Speeds.omegaRadiansPerSecond < 4 * Math.PI
        && frame > m_lastFrameShooter) {
      m_swerve.addVisionMeasurement(limePoseEstReef.pose, limePoseEstReef.timestampSeconds);
    }
    m_lastFrameShooter = frame;
  }


  public double getTargetYawFromFr() {
    double[] temp = LimelightHelpers.getTargetPose_RobotSpace(LL_FR);
    return temp.length == 0 ? 0 : temp[4];
  }

  public double getTargetYawFromFl() {
    double[] temp = LimelightHelpers.getTargetPose_RobotSpace(LL_FL);
    return temp.length == 0 ? 0 : temp[4];
  }

  public double getTargetYawFromBr() {
    double[] temp = LimelightHelpers.getTargetPose_RobotSpace(LL_BR);
    return temp.length == 0 ? 0 : temp[4];
  }

  public double getTargetYawFromBl() {
    double[] temp = LimelightHelpers.getTargetPose_RobotSpace(LL_BL);
    return temp.length == 0 ? 0 : temp[4];
  }

  public double getTargetYawFromShooter() {
    double[] temp = LimelightHelpers.getTargetPose_RobotSpace(LL_SHOOTER);
    return temp.length == 0 ? 0 : temp[4];
  }

  private void updateOdometry() {
//     Subsystem.swerve.setVisionMeasurementStdDevs(VecBuilder.fill(0.7, 0.7, 9999999));
//     // if aligning to an algae position, force odometry updates from reef.
//     if (getTvReef1() && (m_deAlgaefying || Subsystem.coral.hasCoral() || Subsystem.algae.hasAlgae())) {
//       updateOdometryReef1();
//       return;
//     } else if (getTvReef2() && (m_deAlgaefying || Subsystem.coral.hasCoral() || Subsystem.algae.hasAlgae())) {
//       updateOdometryReef2();
//       return;
//     }
//     if (getTvStation()) {
//       updateOdometryStation();
//     }
//   }
    if (getTvFr()) {
      updateOdometryFr();
      return;
    }
    if (getTvFl()) {
      updateOdometryFl();
      return;
    }
    if (getTvBr()) {
      updateOdometryBr();
      return;
    }
    if (getTvBl()) {
      updateOdometryBl();
      return;
    }
    if (getTvShooter()) {
      updateOdometryShooter();
      return;
    }

    // boilerplate 
  }

  private double getFrame(String limelight) {
    return NetworkTableInstance.getDefault().getTable(limelight).getEntry("hb").getDouble(-1);
  }

  private void ManageLimelightTemperature() {
    m_slow_count++;
    if (m_enabled && (m_slow_count % 50) != 0) {
      return;
    }
    // update at 1Hz or when disabled
    m_enabled = DriverStation.isEnabled();
  final int throttle = m_enabled ? 0 : 169;
  // Apply throttle to all five configured Limelights
  LimelightHelpers.SetThrottle(LL_SHOOTER, throttle);
  LimelightHelpers.SetThrottle(LL_FR, throttle);
  LimelightHelpers.SetThrottle(LL_FL, throttle);
  LimelightHelpers.SetThrottle(LL_BR, throttle);
  LimelightHelpers.SetThrottle(LL_BL, throttle);
  }

  public Command limelightDefaultCommand() {
    return run(() -> {

    });
  }

  @Override
  public void periodic() {
    ManageLimelightTemperature();
  // read the five Limelight tables and store whether each currently sees a target
  m_has_shooter_tag = LimelightHelpers.getTV(LL_SHOOTER);
  m_has_fr_tag = LimelightHelpers.getTV(LL_FR);
  m_has_fl_tag = LimelightHelpers.getTV(LL_FL);
  m_has_br_tag = LimelightHelpers.getTV(LL_BR);
  m_has_bl_tag = LimelightHelpers.getTV(LL_BL);


    //changed - when enabled configure IMU mode for all Limelights we use
    if (m_enabled) {
      LimelightHelpers.SetIMUMode(LL_SHOOTER, 2);
      LimelightHelpers.SetIMUMode(LL_FR, 2);
      LimelightHelpers.SetIMUMode(LL_FL, 2);
      LimelightHelpers.SetIMUMode(LL_BR, 2);
      LimelightHelpers.SetIMUMode(LL_BL, 2);
    }

    if (m_swerve == null) {
      return;
    }



    final var yaw_degrees = Subsystem.swerve.getYawDegrees();
    // according to limelight docs, this needs to be called before using
    // .getBotPoseEstimate_wpiBlue_MegaTag2
  // supply current robot orientation to every Limelight before asking for pose estimates
  LimelightHelpers.SetRobotOrientation(LL_SHOOTER, yaw_degrees, 0, 0, 0, 0, 0);
  LimelightHelpers.SetRobotOrientation(LL_FR, yaw_degrees, 0, 0, 0, 0, 0);
  LimelightHelpers.SetRobotOrientation(LL_FL, yaw_degrees, 0, 0, 0, 0, 0);
  LimelightHelpers.SetRobotOrientation(LL_BR, yaw_degrees, 0, 0, 0, 0, 0);
  LimelightHelpers.SetRobotOrientation(LL_BL, yaw_degrees, 0, 0, 0, 0, 0);
    updateOdometry();
  }

  @Override
  public void simulationPeriodic() {
    // This method will be called once per scheduler run during simulation
  }
}